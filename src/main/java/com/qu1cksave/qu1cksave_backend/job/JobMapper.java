package com.qu1cksave.qu1cksave_backend.job;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.time.Instant;
import java.util.UUID;

// Note:
// https://www.baeldung.com/java-entity-vs-dto
// - This link doesn't have the mapper as a Spring Bean (@Component)
//   So the mapper is used as JobMapper.toDto(jobEntity)
// https://www.baeldung.com/java-dto-pattern
// - Meanwhile, this one has it as a bean
// - It needs to be autowired and used as: jobMapper.toDto(jobEntity)
//   Where jobMapper is the autowired instance set in the constructor
public class JobMapper {
    public static ResponseJobDto toResponseDto(Job entity) {
        // https://stackoverflow.com/questions/2015071/why-boolean-in-java-takes-only-true-or-false-why-not-1-or-0-also
        // - Java, unlike languages like C and C++, treats boolean as a
        //   completely separate data type which has 2 distinct values: true
        //   and false. The values 1 and 0 are of type int and are not
        //   implicitly convertible to boolean
        // - ME: So we need to do entity.getSalaryMin() != null for null check
        //   instead of using the value's truthiness/falsiness
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            return new ResponseJobDto(
                entity.getId(),
                entity.getMemberId(),
                entity.getResumeId(),
                entity.getCoverLetterId(),
                entity.getTitle(),
                entity.getCompanyName(),
                entity.getJobDescription(),
                entity.getNotes(),
                entity.getIsRemote(),
                entity.getSalaryMin(),
                entity.getSalaryMax(),
                entity.getCountry(),
                entity.getUsState(),
                entity.getCity(),
                // Passed as Instant to constructor, which then gets converted
                //   to a String
                entity.getDateSaved(),
                // The code below works for YearMonthDate -> String
                //   YearMonthDate -> String (passed to constructor as String)
                //   Then gets converted to YearMonthDate
                // Reason for this is the native query to get multiple jobs
                entity.getDateApplied() != null ? objectMapper.writeValueAsString(entity.getDateApplied()) : null,
                entity.getDatePosted() != null ? objectMapper.writeValueAsString(entity.getDatePosted()) : null,
                entity.getJobStatus(),
                // Need to convert String[] to String, since JobDto requires a
                //   String. I couldn't use multiple constructors because JPA
                //   wants JobDto to only have one constructor if I'm using it
                //   as a return type for a method in the repository
                entity.getLinks() != null ? objectMapper.writeValueAsString(entity.getLinks()) : null,
                entity.getFoundFrom(),
                null, // Job entity does not have a resume
                null // Job entity does not have a coverLetter
            );
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
    }

    public static Job createEntity(RequestJobDto dto, UUID userId) {
        Job job = new Job();
        // No id since autogenerated
        job.setMemberId(userId);
        job.setResumeId(dto.getResumeId());
        job.setCoverLetterId(dto.getCoverLetterId());
        job.setTitle(dto.getTitle());
        job.setCompanyName(dto.getCompanyName());
        job.setJobDescription(dto.getJobDescription());
        job.setNotes(dto.getNotes());
        job.setIsRemote(dto.getIsRemote());
        job.setSalaryMin(dto.getSalaryMin());
        job.setSalaryMax(dto.getSalaryMax());
        job.setCountry(dto.getCountry());
        job.setUsState(dto.getUsState());
        job.setCity(dto.getCity());
        // No date saved since autogenerated by database
        // If using Map<String, Object> for dateApplied in Job entity
//            YearMonthDateDto.toMap(dto.getDateApplied()),
//            YearMonthDateDto.toMap(dto.getDatePosted()),
        job.setDateApplied(dto.getDateApplied() != null ? YearMonthDateMapper.toEmbeddable(dto.getDateApplied()) : null);
        job.setDatePosted(dto.getDatePosted() != null ? YearMonthDateMapper.toEmbeddable(dto.getDatePosted()) : null);
        job.setJobStatus(dto.getJobStatus());
        job.setLinks(dto.getLinks());
        job.setFoundFrom(dto.getFoundFrom());
        // Job entity does not have a resume or cover letter

        return job;
    }
}

//        return new Job(
//            memberId,
//            dto.getResumeId(),
//            dto.getCoverLetterId(),
//            dto.getTitle(),
//            dto.getCompanyName(),
//            dto.getJobDescription(),
//            dto.getNotes(),
//            dto.getIsRemote(),
//            dto.getSalaryMin(),
//            dto.getSalaryMax(),
//            dto.getCountry(),
//            dto.getUsState(),
//            dto.getCity(),
//            // If using Map<String, Object> for dateApplied in Job entity
////            YearMonthDateDto.toMap(dto.getDateApplied()),
////            YearMonthDateDto.toMap(dto.getDatePosted()),
//            YearMonthDateMapper.toEmbeddable(dto.getDateApplied()),
//            YearMonthDateMapper.toEmbeddable(dto.getDatePosted()),
//            dto.getJobStatus(),
//            dto.getLinks(),
//            dto.getFoundFrom()
//            // Job entity doesn't have a resume/cover letter
//        );
